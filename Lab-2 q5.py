from Crypto.Util.Padding import pad
import numpy as np

# AES S-Box
S_BOX = [
    [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76],
    [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0x4a, 0x2e, 0xe6],
    [0x8d, 0xd5, 0x4c, 0x2c, 0x48, 0x2d, 0x6e, 0x1c, 0x5c, 0x41, 0x67, 0x6f, 0x88, 0x5b, 0x43, 0x99],
    [0x95, 0x15, 0x6d, 0x7c, 0xe5, 0x2b, 0x79, 0x0c, 0x09, 0x39, 0x1e, 0x34, 0x57, 0x2a, 0xd0, 0xd4],
    [0x9a, 0x80, 0xd3, 0x06, 0x78, 0x9d, 0x15, 0xc2, 0xd0, 0x7b, 0xc5, 0xf5, 0xe2, 0x0c, 0x0e, 0x63],
    [0x3c, 0x93, 0x10, 0xe0, 0x01, 0x45, 0xa2, 0x95, 0x1b, 0x57, 0x9f, 0x7a, 0x78, 0xc7, 0x6f, 0x92],
    [0x36, 0x84, 0x30, 0x0f, 0x5b, 0x4e, 0x18, 0x5f, 0x5b, 0x71, 0x8a, 0x9c, 0xe0, 0x7e, 0x93, 0x6b],
    [0x4f, 0x53, 0x7e, 0x63, 0xe1, 0x6e, 0x5d, 0x59, 0x3d, 0x27, 0x1f, 0x6b, 0x4e, 0x65, 0x70, 0x2d],
    [0x0b, 0x47, 0x94, 0xe3, 0x75, 0x26, 0x3e, 0xa0, 0x9f, 0x39, 0x6b, 0x45, 0x54, 0x2d, 0xd4, 0x00],
    [0x6a, 0x72, 0x0e, 0x55, 0xa7, 0x59, 0x1f, 0xa6, 0x78, 0x49, 0x6b, 0x64, 0x88, 0x94, 0xd7, 0x01],
    [0x38, 0x5b, 0xb1, 0xd6, 0xa2, 0x88, 0x5b, 0x75, 0x99, 0x8e, 0x69, 0x57, 0xc0, 0x87, 0x23, 0x41],
    [0xe5, 0x64, 0x26, 0x70, 0xe1, 0x54, 0x2f, 0xc5, 0xa7, 0x2b, 0x46, 0x00, 0x7e, 0x7f, 0xe8, 0x43],
    [0xf4, 0x8b, 0x04, 0xd0, 0x88, 0xd1, 0x27, 0x5e, 0xc4, 0xd2, 0x7f, 0x5b, 0xe7, 0xd0, 0x06, 0x2a],
    [0xf8, 0x8d, 0x5d, 0x2c, 0x29, 0xd1, 0xf1, 0x72, 0x59, 0x77, 0x5e, 0x93, 0xd3, 0xc2, 0x9a, 0xe4],
    [0xf7, 0x77, 0xa6, 0x7a, 0x0e, 0x1c, 0xa2, 0x8f, 0xa8, 0xd4, 0x30, 0x1a, 0x8c, 0x7d, 0xd7, 0xb0],
]

R_CON = [
    [0x01, 0x00, 0x00, 0x00],
    [0x02, 0x00, 0x00, 0x00],
    [0x04, 0x00, 0x00, 0x00],
    [0x08, 0x00, 0x00, 0x00],
    [0x10, 0x00, 0x00, 0x00],
    [0x20, 0x00, 0x00, 0x00],
    [0x40, 0x00, 0x00, 0x00],
    [0x80, 0x00, 0x00, 0x00],
    [0x1b, 0x00, 0x00, 0x00],
    [0x36, 0x00, 0x00, 0x00],
]

def key_expansion(key):
    """Expand the key for AES."""
    key = [int(key[i:i + 2], 16) for i in range(0, len(key), 2)]  # Convert hex to integers
    key_symbols = [key[i:i + 4] for i in range(0, len(key), 4)]  # Split into 4-byte blocks
    expanded_keys = [key_symbols]
    
    for i in range(1, 7):  # 6 rounds for AES-192
        temp = key_symbols[-1][1:] + [key_symbols[-1][0]]  # Rotate the last word
        temp = [S_BOX[b >> 4][b & 0x0f] for b in temp]  # Substitute using S-box
        temp = [temp[j] ^ R_CON[i - 1][j] for j in range(4)]  # XOR with RCON
        new_key = [key_symbols[-4][j] ^ temp[j] for j in range(4)]  # Generate the first word
        expanded_keys.append(new_key)
        
        for j in range(1, 4):
            new_key = [expanded_keys[-1][k] ^ key_symbols[-4 + j][k] for k in range(4)]
            expanded_keys.append(new_key)
        
        key_symbols = expanded_keys[-4:]  # Update the key symbols for the next round
    
    return expanded_keys

def add_round_key(state, round_key):
    """XOR the state with the round key."""
    return [[state[row][col] ^ round_key[row][col] for col in range(4)] for row in range(4)]

def sub_bytes(state):
    """Substitute bytes using the S-box."""
    return [[S_BOX[b >> 4][b & 0x0f] for b in row] for row in state]

def shift_rows(state):
    """Shift the rows of the state."""
    return [
        state[0],
        state[1][1:] + state[1][:1],
        state[2][2:] + state[2][:2],
        state[3][3:] + state[3][:3]
    ]

def mix_columns(state):
    """Mix the columns of the state."""
    mixed = []
    for c in range(4):
        mixed_col = []
        for r in range(4):
            value = (2 * state[r][c] ^ 3 * state[(r + 1) % 4][c] ^ state[(r + 2) % 4][c] ^ state[(r + 3) % 4][c]) % 256
            mixed_col.append(value)
        mixed.append(mixed_col)
    return mixed

def aes_encrypt(plain_text, key):
    """Encrypt the plaintext using AES-192."""
    state = [list(plain_text[i:i + 4]) for i in range(0, len(plain_text), 4)]
    
    # Key Expansion
    expanded_keys = key_expansion(key)
    
    # Initial Round
    state = add_round_key(state, expanded_keys[0])
    
    # Main Rounds
    for i in range(1, 7):
        state = sub_bytes(state)
        state = shift_rows(state)
        state = mix_columns(state)
        state = add_round_key(state, expanded_keys[i])
    
    # Final Round
    state = sub_bytes(state)
    state = shift_rows(state)
    state = add_round_key(state, expanded_keys[6])
    
    return state

# Define the key and plaintext
key = "FEDCBA9876543210FEDCBA9876543210"
plain_text = "Top Secret Data"

# Convert plaintext to bytes and pad
plain_text_bytes = pad(plain_text.encode(), 16)

# Perform AES encryption
cipher_state = aes_encrypt(plain_text_bytes, key)

# Display the final state
print("Final encrypted state:")
for row in cipher_state:
    print(['{:02x}'.format(x) for x in row])
